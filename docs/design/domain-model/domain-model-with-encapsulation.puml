@startuml

title Kilda Domain Model

class SwitchId {
    id
}

class Switch {
    id : SwitchId

    status : SwitchStatus

    controller
    hostname
    address
    description

    meter_max
    __
    unique constraint on switch_id
}

enum SwitchStatus {
    ACTIVE
    INACTIVE
    REMOVED
}

Switch o--> SwitchStatus
Switch o--> SwitchId

enum PortStatus {
    UP
    DOWN
}

class Port {
    switch : Switch
    port_no

    status : PortStatus
    __
    unique constraint on switch_id+port_no
}

Port o--> PortStatus
Port --> Switch

class Rule {
    switch : Switch
    cookie
    meter_id

    path_id
    flow_id
    __
    unique constraint on switch_id+cookie
}

Rule --> Switch

class Isl {
    id = src_switch+src_port+dst_switch+dst_port :  for simplify where clause

    src_switch : Switch
    src_port

    dst_switch : Switch
    dst_port

    forward_status
    forward_latency
    forward_available_bandwidth

    reverse_status
    reverse_latency
    reverse_available_bandwidth

    cost
    speed
    max_bandwidth
    __
    unique constraint on src_switch+src_port+dst_switch+dst_port
}

note "rules for solving whois src and dst\nsrc_switch < dst_switch\n if src_switch == dst_switch use src_port < dst_port" as ISL_id_note
ISL_id_note .. Isl

Isl --> Port : by src and dst endpoints

class IslTemplate {
    src_switch : Switch
    src_port

    dst_switch : Switch
    dst_port

    cost
    max_bandwidth
    __
    unique constraint on src_switch+src_port+dst_switch+dst_port
}

IslTemplate --> Port : by src and dst endpoints

class Flow {
    flow_id

    src_switch : Switch
    src_port
    src_vlan

    dst_switch : Switch
    dst_port
    dst_vlan

    forward : FlowPath
    reverse : FlowPath

    description
    bandwidth
    ignoreBandwidth

    status : FlowStatus
    encapsulationType : FlowEncapsulationType
    __
    unique constraint on flow_id
}

note "rules for solving whois src and dst\nsrc_switch < dst_switch\n if src_switch == dst_switch use src_port < dst_port" as Flow_id_note
Flow_id_note .. Flow

Flow --> Switch
Flow --> FlowPath

class FlowPath {
    path_id

    src_switch : Switch
    dst_switch : Switch

    flow_id
    cookie
    meter_id

    status : FlowStatus
    ==
    pathSegments() : PathSegment[]
    __
    unique constraint on path_id
}

FlowPath --> Switch
FlowPath --> Flow

enum FlowEncapsulationType {
   TRANSIT_VLAN
}

Flow o--> FlowEncapsulationType

enum FlowStatus {
    UP
    DOWN
    IN_PROGRESS
}

Flow o--> FlowStatus

class PathSegment {
    path_id

    src_switch : Switch
    src_port

    dst_switch : Switch
    dst_port

    latency
}

PathSegment --> FlowPath
PathSegment --> Isl : by src and dst endpoints

class FlowMeter {
    switch : Switch
    meter_id

    path_id
    flow_id
    __
    unique constraint on switch_id+meter_id
}

FlowMeter --> Switch
FlowMeter --> Flow
FlowMeter --> FlowPath

class FlowCookie {
    switch : Switch
    cookie

    path_id
    flow_id
    __
    unique constraint on cookie
    unique constraint on path_id
}

FlowCookie --> Switch
FlowCookie --> Flow
FlowCookie --> FlowPath

package "Vlan-based Encapsulation" {

    class TransitVlan {
        path_id

        flow_id
        transit_vlan
        __
        unique constraint on flow_id
    }

    TransitVlan --> FlowPath
    TransitVlan --> Flow
}

@enduml